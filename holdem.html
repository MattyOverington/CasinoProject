<!doctype html>
    <html>
        <head>
            <meta charset="UTF-8">
            <title>Texas Holdem'</title>
            <link rel="stylesheet" type="text/css" href="mystrap.css">
            <script type="text/javascript" src="pixi.js"></script>
        </head>

        <body>

        <canvas id="holdem_canvas"></canvas>

            <script>

//-----------------------------------------------------------------------------------------------------
//Initialization & Global Variables
//-----------------------------------------------------------------------------------------------------


//Global Variable Initializtion and Stuffs
var card_height = 384 / 4;
var card_width = 923 / 13;
var showPlayerPockets = false

var action_fold = "fold"
var action_call = "call"
var action_check = "check"
var action_bet = "bet"
var action_allIn = "all_in"

var user_action;
var player_raise_amount = 0;

var roundCounter = 0;
var currentPlayerName = null;
var potCounter = 0
var recentActions = [];

//Buttons Initialization
var buttons = []
initButtons();

window.addEventListener('mousedown', interperateClick);
window.addEventListener('mousemove', interperateMove);
window.addEventListener('touchstart', interperateContact);
window.addEventListener('touchend', interperatePress)


//Game Initialization
var game = new Game(7, 700, 5, 5, 0.5);
game.createDeck();
game.shuffleDeck();
game.initPlayers(); 


//Canvas Initialization & Initial Render
var canvas;
var context;
var card_img = new Image();
card_img.src = "cards.gif";

initCanvas();
initialCardRender();
clearFloor();


//Game-dependant global variables 
function continueRound(variable) {
    game.continueBettingRound(variable)
}


slow_interval = setInterval(function() {
    game.determineHighBet();
    roundCounter = game.roundNum;
    potCounter = game.pot;
    recentActions = game.player_actions;
}, 500);

fast_interval = setInterval(function() {
    game.buttonAvailability();
    renderScene();
}, 100)

//Starting the Game
setTimeout(function() {
    game.beginRound()
}, 2000);


//Testing Shit Area -----------------------------------------------------------------------------------
card1 = new Card("H", 4)
card2 = new Card("H", 5)
card3 = new Card("D", 6)
card4 = new Card("S", 7)
card5 = new Card("H", 8)

hand1 = [card1, card2, card3, card4, card5]

card6 = new Card("H", 4)
card7 = new Card("H", 5)
card8 = new Card("D", 6)
card9 = new Card("S", 7)
card10 = new Card("H", 8)

hand2 = [card6, card7, card8, card9, card10]

hand1 = game.sortCards(hand1)
hand2 = game.sortCards(hand2)

console.log(hand1, hand2)
console.log(game.determineHand(hand1), game.determineHand(hand2))
console.log(game.compareHands(hand1, hand2))

//-----------------------------------------------------------------------------------------------------



//-----------------------------------------------------------------------------------------------------
//Constructors
//-----------------------------------------------------------------------------------------------------

//Game Constructor

function Game (numberOfPlayers, initialCash, initialSmallBlind, blindRaiseInterval, blindRaisePercentage) {
    if (numberOfPlayers <= 7) {
        this.numberOfPlayers = numberOfPlayers;
    } else {
        this.numberOfPlayers = 7;
    }
    if (initialCash > 0) {
        this.initialCash = initialCash;
    } else {
        this.initialCash = 4000;
    }

    this.smallBlind = initialSmallBlind;
    this.blindRaiseInterval = blindRaiseInterval;
    this.blindRaisePercentage = blindRaisePercentage;

    this.players = [];
    this.deck = [];

    this.roundNum = 0;

    this.community_cards = [];
    this.pot = 0;
    this.highBet = 0;

    this.player_actions = [];
    this.player_bets = [];
    this.player_order = [];
    this.player_order_copy = [];
    this.busted_players = [];

    this.last_raising_player_index = null

    for (i = 0; i < numberOfPlayers; i++) {
        this.player_order.push(i);
        this.player_bets.push(0);
    }

    this.hands = ["Straight Flush", "Four of a Kind", "Full House", "Flush", "Straight", "Three of a Kind", "Two Pair", "Pair", "Junk"]


    this.bigBlind = this.smallBlind * 2;
    this.minimumBet = this.smallBlind;

    this.beginRound = function() {
        this.roundNum += 1
        this.community_cards = [];
        this.pot = 0;
        this.player_actions.push("Round " + this.roundNum + " Started");
        this.bigBlind = this.smallBlind * 2;
        this.minimumBet = this.smallBlind;

        this.createDeck()
        this.shuffleDeck()

        temp = this.player_order.slice()

        for (i = 0; i < temp.length; i++) {
            if (i == 0) {
                this.player_order[0] = this.player_order[this.player_order.length - 1]
            } else {
                this.player_order[i] = temp[i - 1]
            }
        }

        console.log(this.player_order)

        
        this.player_order_copy = this.player_order.slice()

        len = this.players.length

        for (i = 0; i < len; i++) {
            player = this.players[i]
            player.currentHand = []
            this.player_bets[i] = 0
        }

        for (i = 0; i < len; i++) {
            this.giveCard(i)
        }
        for (i = 0; i < len; i++) {
            this.giveCard(i)
        }

        blind_player_index = this.player_order[this.player_order.length - 1]
        sblind_player_index = this.player_order[this.player_order.length - 2]

        blind_player = this.players[blind_player_index]
        sblind_player = this.players[sblind_player_index]

        this.bet(blind_player, this.bigBlind)
        this.bet(sblind_player, this.smallBlind)

        this.player_actions.push(sblind_player.name + " posted small blind of $" + this.smallBlind)
        this.player_actions.push(blind_player.name + " posted big blind of $" + this.bigBlind)

        renderScene()

        this.nextStage = this.dealFlop


        this.initialBettingRound()
    }

    this.initialBettingRound = function() {
        this.last_raising_player_index = 0
        this.startBettingRound(0)
    }

    this.bettingRound = function() {
        this.startBettingRound(this.last_raising_player_index)
    }

    this.startBettingRound = function(i) {
        index = this.player_order_copy[i]
        player = this.players[index];

        action = null

        player.hasCurrentTurn = true
        currentPlayerName = player.name

        if (player.isAI == false && player.isAllIn == false) {
            console.log("Awaiting player action")
            return null
        } else {
            self = this
            action = action_call
            temp_player = player
            ind = index

            setTimeout(function() {

                self.bettingAction(i, ind, temp_player, action)
                self.players[ind].hasCurrentTurn = false;

                if (i + 1 == self.last_raising_player_index || (self.last_raising_player_index == 0 &&  i == self.player_order_copy.length - 1)) {
                    self.determineEndOfBettingRound()
                } else if (action == action_fold || action == action_allIn) {
                    if (i == self.player_order_copy.length) { 
                        self.startBettingRound(0)
                    } else {
                        self.startBettingRound(i)
                    }
                } else {
                    if (i == self.player_order_copy.length - 1) { 
                        self.startBettingRound(0)
                    } else {
                        self.startBettingRound(i + 1)
                    }
                }
            }, 500)
        }
    }

    this.continueBettingRound = function(action) {
        user = this.players[0]
        ix = this.player_order_copy.indexOf(0)

        self = this
        temp_player = user
        ind = ix

        setTimeout(function() {
            self.bettingAction(ind, 0, temp_player, action)
            self.players[0].hasCurrentTurn = false;

            player_raise_amount = 0
            if (ind + 1 == self.last_raising_player_index || (self.last_raising_player_index == 0 &&  ind == self.player_order_copy.length - 1)) {
                    self.determineEndOfBettingRound()
                } else if (action == action_fold || action == action_allIn) {
                    if (ind == self.player_order_copy.length) { 
                        self.startBettingRound(0)
                    } else {
                        self.startBettingRound(ind)
                    }
                } else {
                    if (ind == self.player_order_copy.length - 1) { 
                        self.startBettingRound(0)
                    } else {
                        self.startBettingRound(ind + 1)
                    }
                }
        }, 500)
    }

    this.bettingAction = function(i, index, player, action) {
        if (action == action_fold) {
            this.player_order_copy.splice(i, 1)
            this.player_bets[index] = null
            this.player_actions.push(player.name + " Folded")
        } else if (action == action_call) {
            amount = this.highBet - this.player_bets[index]
            this.bet(player, amount)
            this.player_actions.push(player.name + " Called $" + amount)
        } else if (action == action_check) {
            this.player_actions.push(player.name + " Checked")
        } else if (action == action_bet) {

            if (player.hasHighBet == false) {
                raise = (this.player_bets[i] + player_raise_amount) - this.highBet
            } else {
                raise = player_raise_amount
            }

            if (player_raise_amount == player.balance) {
                this.bettingAction(i, index, player, action_allIn)
            } else if (raise > 0) {
                this.bet(player, player_raise_amount)
                this.last_raising_player_index = i
                this.player_actions.push(player.name + " Raised $" + raise)
            } else {
                this.bet(player, player_raise_amount)
                this.player_actions.push(player.name + " Called $" + player_raise_amount)
            }

        } else if (action == action_allIn) {
            this.bet(player, player.balance)
            this.player_order_copy.splice(i, 1)
            player.isAllIn = true
            this.player_actions.push(player.name + " Went All In With $" + player.balance)
        }
    }

    //-------------------------------------------------------------------------------------------------------//
    //--------------------------       AI WRITING ZONE        -----------------------------------------------//
    //-------------------------------------------------------------------------------------------------------//

    this.determineHand = function(cards) {
        if (cards.length < 5) {
            return null
        } else {
            if (this.isRoyalFlush(cards)) {

            }
        }
    }

    this.ratingAIresponse = function(player) {
        hand_cards = player.currentHand 
        comm_cards = this.community_cards

        known_hands = []
        possible_hands = []  
    }

    //--------------------------------------------------------------------------------------------------------//
    //--------------------------------------------------------------------------------------------------------//
    //--------------------------------------------------------------------------------------------------------//


    this.determineEndOfBettingRound = function() {
        var continue_betting = false

        if (!equalValues(this.player_bets)) {
            for (i = 0; i < this.player_order_copy.length; i++) {
                if (this.player_bets[i] != this.highBet && this.players[i].isAllIn == false) {
                    continue_betting == true
                }
            }
        }

        if (this.player_order_copy.length == 1) {
            continue_betting = false
        }

        if (continue_betting == true) {
            this.bettingRound()
        } else {
            this.nextStage()
        }
    }

    this.determineWinner = function() {
        if (this.player_order_copy.length == 1) {
            winner = this.players[this.player_order_copy[0]]
            winner.balance += this.pot
            recentActions.push(winner.name + " won")
            recentActions.push(winner.name + " took pot of $" + this.pot)
        } else {
            this.showdown()
        }
        showPlayerPockets = true
        for (i = 0; i < this.players.length; i++) {
            player = this.players[i]
            if (player.balance <= 0 && player.is_bust == false) {
                index = this.player_order.indexOf(i)
                this.player_order.splice(index, 1)
                player.is_bust = true
                recentActions.push(player.name + " bust")
            }
        }
        if (this.player_order.indexOf(0) == -1) {
            recentActions.push("You Bust!")
        } else if (this.players.length == 1) {
            recentActions.push("You won!")
        } else {
            self = this
            setTimeout(function() {
                showPlayerPockets = false
                self.beginRound()
            }, 15000)
        }
    }

//-----------------------------------------------------------------------------------------------------------
///----------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------

    this.showdown = function() {
        
        best_hands = []

        for (i = 0; i < this.player_order_copy.length; i++) {
            best_hands.push(null)
        }

        for (i1 = 0; i1 < this.player_order_copy.length; i1++) {
            player = this.players[this.player_order_copy[i1]]

            pockets = player.currentHand
            available_cards = []
            available_hands = []

            //Combine community cards and hand together 

            available_cards.push(this.community_cards[0])
            available_cards.push(this.community_cards[1])
            available_cards.push(this.community_cards[2])
            available_cards.push(this.community_cards[3])
            available_cards.push(this.community_cards[4])
            available_cards.push(pockets[0])
            available_cards.push(pockets[1])

            misc_array = [0, 1, 2, 3, 4, 5]
            //Use this to prevent duplicates being put in. 

            for (a = 0; a < available_cards.length; a++) {
                temp_hand1 = available_cards.slice()

                temp_hand1.splice(a, 1)
                for (b = 0; b < misc_array.length; b++) {
                    x = misc_array[b]
                    temp_hand = temp_hand1.slice()
                    temp_hand.splice(x, 1)
                    if ((a == 6 && x == 5) || (a == 5 && x == 5)) {
                        //Not a valid hand, too many pocket cards
                    } else {
                        temp_hand = this.sortCards(temp_hand)
                        available_hands.push(temp_hand) 
                        if (b == misc_array.length - 1) {
                            misc_array.splice(0, 1)
                        }
                    }
                }
            }




            //Find best hand from the bunch

            best_hand = null
            best_rating = 1000

            for (a = 0; a < available_hands.length; a++) {
                hand = available_hands[a]

                rating = this.determineHand(hand)

                if (rating < best_rating) {
                    best_hand = hand
                    best_rating = rating
                } else if (rating == best_rating) {
                    better = this.compareHands(hand, best_hand)
                    if (better == 0) {
                        best_hand = hand
                    } else {
                        //No change
                    }
                }

            }

            best_hands[this.player_order_copy[i1]] = best_hand

        }

        //Now find best best hand
        console.log(best_hands)
        best_hand = null
        best_rating = 1000
        best_hand_index = 0

        drawn_players = []

        for (a = 0; a < best_hands.length; a++) {
            hand = best_hands[a]
            if (hand != null) {
                rating = this.determineHand(hand)

                if (rating < best_rating) {
                    best_hand = hand
                    best_rating = rating
                    best_hand_index = a
                    drawn_players = []
                } else if (rating == best_rating) {
                    better = this.compareHands(hand, best_hand)
                    if (better == 0) {
                        best_hand = hand
                        best_rating = rating
                        best_hand_index = a
                        drawn_players = []
                    } else if (better == 1) {
                        //No change
                    } else if (better == null) {
                        drawn_players.push(a)
                    }
                }
            }

        }

        console.log(this.players[best_hand_index], best_hand)

        //Do winner things

        if (drawn_players.length > 0) {
            console.log(best_hand, this.hands[best_rating], drawn_players)

            split = this.pot / drawn_players.length
            drawn_player_names = ""

            if (Math.ceil(split) != split + 1) {
                split = Math.ceil(split)
            }
            for (ka = 0; ka < drawn_players.length; ka++) {
                player = this.players[drawn_players[ka]]
                player.balance += split
                recentActions.push(player.name + " drew and won $" + split)
            }
        } else {
            winner = this.players[best_hand_index]
            winner.balance += this.pot
            recentActions.push(winner.name + " won with " + this.hands[best_rating])
            recentActions.push(winner.name + " took pot of $" + this.pot)
        }
    }

    this.compareHands = function(first_hand, second_hand) {
        //Array to get best hand from two of the same type of hand
        rating = this.determineHand(first_hand)

        if (rating == 0 || rating == 3 || rating == 4 || rating == 8) {
            //Draw determiner for ALL FLUSH, STRAIGHT and JUNK hands
            for (i = first_hand.length - 1; i >= 0; i--) {
                //Simply loop backward through the array and compare values for straights, flushes, etcetera
                first_card = first_hand[i]
                second_card = second_hand[i]
                if (first_card.number > second_card.number) {
                    return 0 
                } else if (second_card.number > first_card.number) {
                    return 1
                } else if (i == 0) {
                    return null
                }
            }
        } else if (rating == 1) {
            //Draw determiner for FOUR OF A KIND HANDS
            //Simply compare first card then last card - if same, return one, check in winner function to split pot
            if (first_hand[0].number > second_hand[0].number) {
                return 0
            } else if (second_hand[0].number > first_hand[0].number) {
                return 1
            } else {
                if (first_hand[4].number > second_hand[4].number) {
                    return 0
                } else if (second_hand[4].number > first_hand[4].number) {
                    return 1
                } else {
                    return null
                }
            }
        } else if (rating == 2) {
            //Draw determiner for FULL HOUSE HANDS
            // First find out where trio is for both hands
            first_trio_position = -1
            second_trio_position = -1

            if (first_hand[1].number == first_hand[2].number) {
                first_trio_position = 0
            } else {
                first_trio_position = 2
            }

            if (second_hand[1].number == second_hand[2].number) {
                second_trio_position = 0
            } else {
                second_trio_position = 2
            }

            second_pair_position = Math.abs(second_trio_position - 2)
            first_pair_position = Math.abs(first_trio_position - 2)

            //Now compare trio, then pair

            if (second_hand[second_trio_position].number > first_hand[first_trio_position].number) {
                return 1
            } else if ((second_hand[second_trio_position].number < first_hand[first_trio_position].number)) {
                return 0
            } else {
                if (second_hand[second_pair_position].number > first_hand[first_pair_position].number) {
                    return 1
                } else if ((second_hand[second_pair_position].number < first_hand[first_pair_position].number)) {
                    return 0
                } else {
                    return null
                }
            }

        } else if (rating == 5) {
            //Draw determiner for THREE OF A KIND HANDS
            //compare first two then loop back

            if (second_hand[0].number > first_hand[0].number) {
                return 1
            } else if (second_hand[0].number < first_hand[0].number) {
                return 0
            } else {
                for (i = 4; i >= 3; i--) {
                    if (second_hand[i].number > first_hand[i].number) {
                        return 1
                    } else if (second_hand[i].number < first_hand[i].number) {
                        return 0
                    } else if (i == 3) {
                        return null
                    }
                }
            }
        } else if (rating == 6) {
            //Draw determiner for TWO PAIR HANDS
            //first find highest pair for each hand
            //Compare first pair, then second pair, then last cards
            if (second_hand[0].number > first_hand[0].number) {
                return 1
            } else if (second_hand[0].number < first_hand[0].number) {
                return 0
            } else {
                if (second_hand[2].number > first_hand[2].number) {
                    return 1
                } else if (second_hand[2].number < first_hand[2].number) {
                    return 0
                } else {
                    if (second_hand[4].number > first_hand[4].number) {
                        return 1
                    } else if (second_hand[4].number < first_hand[4].number) {
                        return 0
                    } else {
                        return null
                    }
                }
            }
        } else if (rating == 7) {
            //Draw determiner for PAIR HANDS
            //Compare first then loop back
            if (second_hand[0].number > first_hand[0].number) {
                return 1
                } else if (second_hand[0].number < first_hand[0].number) {
                    return 0
                } else {
                    for (i = 4; i >= 2; i--) {
                        if (second_hand[i].number > first_hand[i].number) {
                            return 1
                        } else if (second_hand[i].number < first_hand[i].number) {
                            return 0
                        } else if (i == 2) {
                            return null
                        }
                    }
                }

        }


    }

//------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------

    this.bet = function(player, amount) {
        this.pot += amount;
        player.balance -= amount;
        this.player_bets[this.players.indexOf(player)] += amount
    }


    this.nextStage = function() {

    }

    this.dealFlop = function() {
        this.community_cards.push(this.dealCard())
        this.community_cards.push(this.dealCard())
        this.community_cards.push(this.dealCard())

        this.nextStage = this.dealTurn

        recentActions.push("Flop")

        renderScene();

        this.initialBettingRound()
    }

    this.dealTurn = function() {
        this.community_cards.push(this.dealCard())

        this.nextStage = this.dealRiver

        recentActions.push("Turn")

        renderScene()

        this.initialBettingRound()
    }

    this.dealRiver = function() {
        this.community_cards.push(this.dealCard())

        this.nextStage = this.determineWinner

        recentActions.push("River")

        console.log(this.determineHand(this.community_cards))

        renderScene()

        this.initialBettingRound()
    }
    

    this.createDeck = function() {
        suits = ["D", "H", "C", "S"];
        list = []

        for (i = 0; i < 4; i++) {
            for (j = 2; j <= 14; j++) {
                temp = new Card(suits[i], j);
                list.push(temp);
            }
        }

        this.deck = list;
    }

    this.dealCard = function() {
        cardz = this.deck[0];

        this.deck.splice(0, 1);
        return cardz    ;
    }

    this.giveCard = function(p) {
        player = game.players[p];

        player.currentHand.push(this.dealCard());
    }

    this.shuffleDeck = function() {

        temp = []
        len = this.deck.length;

        for (i = 0; i < len + 1; i++) {
            j = Math.floor(Math.random() * (52 - i))
            temp.push(this.deck[j])
            this.deck.splice(j, 1);
        }

        this.deck = temp;
    }

//------------------------------------------------------------------------------------------------
//-------------------------------- CARD AND WINNER HANDLING --------------------------------------
//------------------------------------------------------------------------------------------------


    this.sortCards = function(cards) {
        numbers = []
        new_cards = []

        for (i = 0; i < cards.length; i++) {
            numbers.push(cards[i].number)
            new_cards.push(cards[i])
        }

        numbers.sort(function(a, b) {return a - b})

        streak = 0
        temp = []

        for (i = 0; i <= cards.length; i++) {
            if (i != 0) {
                if (numbers[i] == numbers[i-1]) {
                    streak += 1
                } if ( streak > 0 && (numbers[i] != numbers[i-1] || i == cards.length) ) { 
                    
                    initial = i - (streak + 1)

                    for (j = initial; j < initial + (streak + 1); j++) {
                        temp.push(numbers[j])
                    }
                    

                    numbers.splice(initial, streak + 1)

                    for (k = 0; k < temp.length; k++) {
                        numbers.splice(0, 0, temp[k])
                    }


                    streak = 0
                    temp = []
                }
            }
        }

        for (i = 0; i < cards.length; i++) {
            index = numbers.indexOf(cards[i].number)
            numbers[index] = null
            new_cards[index] = cards[i]
        }

        return new_cards
    }

    this.determineHand = function(cards) {
        cards = this.sortCards(cards)

        if (this.isStraight(cards) && this.isFlush(cards)) {
            return 0
        } else if (this.isFourK(cards)) {
            return 1
        } else if (this.isFullHouse(cards)) {
            return 2
        } else if (this.isFlush(cards)) {
            return 3
        } else if (this.isStraight(cards)) {
            return 4
        } else if (this.isThreeK(cards)) {
            return 5
        } else if (this.isTwoPair(cards)) {
            return 6
        } else if (this.isPair(cards)) {
            return 7
        } else {
            return 8
        }
    }

    this.isStraight = function(cards) {
        straight = true
        if (cards[0].number==2&&cards[1].number==3&&cards[2].number==4&&cards[3].number==5&&cards[4].number==14) {
            straight = true
        } else {
            for (i = 0; i < cards.length - 1; i++) {
                if (cards[i].number != (cards[i + 1].number - 1)) {
                    straight = false
                }
            }
        }
        return straight
    }

    this.isFlush = function(cards) {
        flush = true
        for (i = 0; i < cards.length - 1; i++) {
            if (cards[i].suit != cards[i+1].suit) {
                flush = false
            }
        }
        return flush
    }

    this.isFourK = function(cards) {
        isfour = true   
        for (i = 0; i < cards.length - 2; i++) {
            if (cards[i].number != cards[i + 1].number) {
                isfour = false
            }
        }
        return isfour
    }

    this.isFullHouse = function(cards) {
        isfull = false

        if (cards[0].number == cards[1].number) {
            //First two are pair
            if (cards[1].number == cards[2].number) {
                //First three are trio
                if (cards[3].number == cards[4].number) {
                    //Last two are pair, full house!
                    isfull = true
                }
            } else if (cards[2].number == cards[3].number && cards[3].number == cards[4].number) {
                //Last 3 are trio
                isfull = true
            }
        } 

        return isfull
    }

    this.isThreeK = function(cards) {
        isthree = false
        if (cards[0].number == cards[1].number) {
            if (cards[1].number == cards[2].number) {
                isthree = true
            }
        }
        return isthree
    }

    this.isTwoPair = function(cards) {
        istwo = false
        if (cards[0].number == cards[1].number) {
            if (cards[2].number == cards[3].number) {
                istwo = true
            }
        } 
        return istwo
    }

    this.isPair = function(cards) {
        ispair = false
        if (cards[0].number == cards[1].number) {
            ispair = true
        }
        return ispair
    }

//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------


    this.initPlayers = function() {
        colours = ["red", "blue", "green", "yellow", "cyan", "maroon", "white"];
        names = ["Jeff", "Milo", "Duffy", "Goro", "Wezza", "Alex", "Jeff"]
        for (i = 0; i <  this.numberOfPlayers; i++) {
            temp = new Player (i, colours[i], names[i], Math.floor(this.initialCash/this.numberOfPlayers), true);
            if (i == 0) {
                temp.isAI = false;
                temp.name = 'Fezza';
            }
            this.players.push(temp); 
        }
    }
    this.determineHighBet = function() {
        this.highBet = maxOfArray(this.player_bets)

        index = this.player_bets.indexOf(this.highBet)

        for (i = 0; i < this.player_order_copy.length; i++) {
            if (this.highBet != undefined) {
                if (index == i) {
                    this.players[index].hasHighBet = true
                } else {
                    this.players[i].hasHighBet = false
                }
            } else {
                this.players[i].hasHighBet = null
            }
        }   

        if (this.highBet == undefined) {
            highest = 0
            for (i = 0; i < this.player_order_copy.length; i++) {
                if (this.player_bets[i] > highest) {
                    highest = this.player_bets[i]
                }
            }

            this.highBet = highest
        }
    }

    this.buttonAvailability = function() {
        foldButton = buttons[0]
        checkButton = buttons[1]
        callButton = buttons[2]
        add5button = buttons[3]
        add10button = buttons[4]
        add50button = buttons[5]
        add100button = buttons[6]
        allInButton = buttons[7]
        betButton = buttons[8]

        user_bet = this.player_bets[0]
        user = this.players[0]

        for (i = 0; i < buttons.length; i++) {
            button = buttons[i]
            if (user.hasCurrentTurn == true) {
                button.enabled = true
            } else {
                button.enabled = false
            }
        }

        user_balance = user.balance

        if (player_raise_amount + 5 > user_balance) {
            add5button.enabled = false
        } if (player_raise_amount + 10 > user_balance) {
            add10button.enabled = false
        } if (player_raise_amount + 50 > user_balance) {
            add50button.enabled = false
        } if (player_raise_amount + 100 > user_balance) {
            add100button.enabled = false
        } 

        if (this.player_bets[0] < this.highBet) {
            checkButton.enabled = false
            if (player_raise_amount + this.player_bets[0] < this.highBet) {
                betButton.enabled = false
            }
        } else if (this.player_bets[0] == this.highBet || (this.highBet -this.player_bets[0])>=this.players[0].balance) {
            callButton.enabled = false;
        }
    }

}

//Card Constructor

function Card (suit, number) {
    this.suit = suit;
    this.number = number;
}

//Player Constructor

function Player (number, colour, name, balance, isAI) {
    this.number = number;
    this.colour = colour;
    this.name = name;
    this.balance = balance;
    this.rank = 0;
    this.isAI = isAI;
    this.is_bust = false

    this.currentHand = [];
    this.hasCurrentTurn = false;
    this.hasHighBet = false;
    this.isAllIn = false;
}

function Button (name, x, y, width, height, displayText, action) {
    this.name = name;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.displayText = displayText;
    this.action = action;
    this.enabled = false;
    this.isHover = false;
}

//-----------------------------------------------------------------------------------------------------
//Canvas & Miscellaneous Methods
//-----------------------------------------------------------------------------------------------------

function initCanvas() {
    canvas = document.getElementById("holdem_canvas");
    canvas.height = window.innerHeight;     
    canvas.width = window.innerWidth;
    context = canvas.getContext("2d");
}

function percentageToAbsolute(value, isX) {
    if (isX == true) {
        return value * window.innerWidth
    } else {
        return value * window.innerHeight
    }
}

function equalValues(array) {

    for (var i = 1; i < array.length; i++) {
        if (array[i] !== array[0]) {
            return false;
        }
    }

    return true;
}

function maxOfArray(array) {
    return Math.max.apply(null, array);
}

//-----------------------------------------------------------------------------------------------------
//Control and Interaction Methods
//-----------------------------------------------------------------------------------------------------

function interperateClick(event) {
    mousex = event.pageX - canvas.offsetLeft;
    mousey = event.pageY - canvas.offsetLeft;

    console.log(mousex/window.innerWidth, 1 - mousey/window.innerWidth)

    for (i = 0; i < buttons.length; i++) {
        button = buttons[i];
        if (mousex >= button.x && mousey >= button.y) {
            if (mousex <= (button.x + button.width) && mousey <= (button.y + button.height) && button.enabled == true) {
                if (i == 3 || i == 4 || i == 5 || i == 6 ) {
                    player_raise_amount += button.action
                } else if (i == 0 || i == 1 || i == 2 || i == 7 || i == 8) {
                    button.enabled = false
                    button.isHover = false
                    continueRound(button.action)
                }
            }
        }
    }
}


function interperateMove(event) {
    mousex = event.pageX - canvas.offsetLeft;
    mousey = event.pageY - canvas.offsetLeft;

    for (i = 0; i < buttons.length; i++) {
        button = buttons[i];
        if (mousex >= button.x && mousey >= button.y) {
            if (mousex <= (button.x + button.width) && mousey <= (button.y + button.height) && button.enabled == true) {
                button.isHover = true
            } else {
                button.isHover = false
            }
        } else {
            button.isHover = false
        }
    }
}

function interperateContact(event) {
    interperateMove(event)
}

function interperatePress(event) {
    interperateClick(event)
}

function initButtons() {

    firstrowpercentage = 0.757
    secondrowpercentage = 0.801


    buttony = percentageToAbsolute(firstrowpercentage, false)
    buttony2 = percentageToAbsolute(secondrowpercentage, false)
    buttonHeight = 18;

    //Set Various X and Y Percentages

    x1 = percentageToAbsolute(0.459, true)
    x2 = percentageToAbsolute(0.497, true)
    x3 = percentageToAbsolute(0.542, true)
    x4 = percentageToAbsolute(0.580, true)

    x5 = percentageToAbsolute(0.459, true)
    x6 = percentageToAbsolute(0.489, true)
    x7 = percentageToAbsolute(0.518, true)
    x8 = percentageToAbsolute(0.548, true)
    x9 = percentageToAbsolute(0.584, true)

    //Assign Buttons and Functions for Row 1

    foldButton = new Button('fold', x1, buttony, 40, buttonHeight, "Fold", action_fold);

    checkButton = new Button('check', x2, buttony, 50, buttonHeight, "Check", action_check);

    callButton = new Button('call', x3, buttony, 40, buttonHeight, "Call", action_call);

    allInButton = new Button('all in', x4, buttony, 50, buttonHeight, "All In", action_allIn);

    //Assign buttons and functions for Row 2

    add5button = new Button('raise 5', x5, buttony2, 30, buttonHeight, "$5", 5);

    add10button = new Button('raise 10', x6, buttony2, 30, buttonHeight, "$10", 10);

    add50button = new Button('raise 50', x7, buttony2, 30, buttonHeight, "$50", 50);

    add100button = new Button('raise 100', x8, buttony2, 40, buttonHeight, "$100", 100);

    betButton = new Button('bet', x9, buttony2, 45, buttonHeight, "Raise", action_bet);

    buttons.push(foldButton);
    buttons.push(checkButton);
    buttons.push(callButton);
    buttons.push(add5button);
    buttons.push(add10button);
    buttons.push(add50button);
    buttons.push(add100button);
    buttons.push(allInButton);
    buttons.push(betButton);
}


//-----------------------------------------------------------------------------------------------------
//Rendering Methods
//-----------------------------------------------------------------------------------------------------


function renderScene() {
    clearFloor();
    renderPlayerIcons();
    renderButtons();
    renderStats(); 
    renderRecentActions(); 
    renderCards();

    if (showPlayerPockets == true) {
        renderPocketCards();
    }
}

function renderPlayerIcons() {
    for (i = 0; i < game.numberOfPlayers; i++) {

        player = game.players[i];
        dotx = (window.innerWidth - (90 * (game.numberOfPlayers - 1)))/2 + (90 * player.number);
        namex = dotx + 20
        cashx = dotx + 20;       
        
        context.beginPath();
        context.arc(dotx, 25 , 10, 0, 2 * Math.PI, false);
        context.fillStyle = player.colour;
        context.lineWidth = 6;
        if (player.hasCurrentTurn == true) {
            context.strokeStyle = 'orange';
        } else {
            context.strokeStyle = 'black';
        }
        context.stroke();
        context.fill();

        context.font = "14px Century"
        context.fillStyle = 'black'
        context.fillText(player.name, namex, 50)

        context.fillStyle = 'white'
        context.fillText("$" + player.balance, cashx, 29) 

        context.fillStyle = "orange"

        if (game.player_bets[i] == null) {
            context.fillText("Folded", cashx, 71)
        } else if (game.players[i].is_bust == true) {
            context.fillStyle = "Red"
            context.fillText("Busted", cashx, 71)
        } else {
            context.fillText("$" + game.player_bets[i], cashx, 71)
        }

    }
}

function renderPocketCards() {
    for (i1 = 0; i1 < game.player_order_copy.length; i1++) {
        index = game.player_order_copy[i1]
        player = game.players[index]

        pockets = player.currentHand

        cardy = 85
        initialx = (window.innerWidth - (90 * (game.numberOfPlayers - 1)))/2 + (90 * player.number);
        xoffset = 20

        for (j = 0; j < 2; j++) {
            renderSmallerCard(pockets[j], initialx + (xoffset * j), cardy)
        }
    }
}

function renderButtons() {
    for(i = 0; i < buttons.length; i++) {

        widthpercentage = button.width / 1360
        heightpercentage = button.height / 681

        buttonwidth = percentageToAbsolute(widthpercentage, true)
        buttonheight = percentageToAbsolute(heightpercentage, false)

        button = buttons[i];
        context.beginPath();
        context.rect(button.x, button.y, button.width, button.height);
        if (button.isHover == true) {
            context.strokeStyle = 'orange';
        } else {
            context.strokeStyle = 'black';
        }
        context.fillStyle = 'maroon'
        context.lineWidth = 5
        context.stroke()
        context.fill()

        context.font = "14px Century"
        context.fillStyle = 'white'
        context.fillText(button.displayText, button.x + 5, button.y + 13)
    }
}
function renderStats() {
    player = game.players[0]

    xpercentage = 0.463
    ypercentage = 0.694

    x = percentageToAbsolute(xpercentage, true);
    y = percentageToAbsolute(ypercentage, false);

    context.font = 'Bold 64px Century'
    context.fillStyle = 'black'
    context.fillText("$" + player.balance, x, y);

    x = percentageToAbsolute(0.379, true)
    y = percentageToAbsolute(0.805, false)
    context.font = "Bold 36px Century"
    context.fillText("$" + player_raise_amount, x, y)

    //x = percentageToAbsolute(0.24, true)
    //y = percentageToAbsolute(0.64, false)
    //context.font = "Bold 24px Century"
    //context.fillText("Round " + roundCounter, x, y)

    //y = percentageToAbsolute(0.68, false)
    //context.fillText(currentPlayerName + "'s turn", x, y)

    x = percentageToAbsolute(0.45, true)
    y = percentageToAbsolute(0.45, false)
    context.font = "Bold 30px Century"
    context.fillText("Pot: $" + potCounter, x, y)
}

function renderRecentActions() {
    context.globalAlpha = 0.8
    x = percentageToAbsolute(0.726, true)
    y = percentageToAbsolute(0.2, false)
    width = percentageToAbsolute(0.24, true)
    height = percentageToAbsolute(0.7, false)
    context.fillStyle = 'white'
    context.fillRect(x, y, width, height)
    context.globalAlpha = 1;

    constx = 0.732
    initialy = 0.24- 0.045

    context.fillStyle = 'black'
    context.font = "Bold 18px Century"

    if (recentActions.length >= 16) {
        recentActions.splice(0, 1)
    }

    for (i = recentActions.length - 1; i >= 0; i--) {
        x = percentageToAbsolute(constx, true)
        y = percentageToAbsolute(initialy + 0.045 * (recentActions.length - i), false)
        if (isSpecialEvent(recentActions[i]) != null) {
            context.fillStyle = isSpecialEvent(recentActions[i])
        } else {
            context.fillStyle = "black"
        }
        context.fillText(recentActions[i], x, y)
    }
}

function isSpecialEvent(event_name) {
    if (event_name == "River" || event_name == "Flop" || event_name == "Turn") {
        return "blue"
    } if (event_name.split(" ")[0] == "Round") {
        return "green" 
    } if (event_name.split(" ")[1] == "won") {
        return "orange"
    } if (event_name.split(" ")[1] == "took") {
        return "orange"
    } if (event_name.split(" ")[-1] == "bust") {
        return "red"
    }
    
    return null
}

function renderCards() {
    renderStartingHand();
    renderCommunityCards();
}

function initialCardRender() {
       card_img.onload = function() {
        renderStartingHand();
        renderCommunityCards();
    } 
}

function renderStartingHand() {
    player = game.players[0]
    cards = player.currentHand

    startxpercentage = 0.378;
    ypercentage = 0.588

    startx = percentageToAbsolute(startxpercentage, true);
    y = percentageToAbsolute(ypercentage, false)

    for (i = 0; i < 2; i ++) {
        renderCard(cards[i], startx + (i * 40), y);
    }
}

function renderCommunityCards() {
    cards = game.community_cards
    ypercentage = 0.25;
    startxpercentage = 0.3566;
    offsetPercentage = 0.05882;
    
    startx = percentageToAbsolute(startxpercentage, true);
    offset = percentageToAbsolute(offsetPercentage, true);
    y = percentageToAbsolute(ypercentage, false);

    for (i = 0; i < cards.length; i++) {
        renderCard(cards[i], startx + (i * 80), y);
    }
}

function renderCard(card, x, y) {

    suits = ["D", "H", "C", "S"];

    row = suits.indexOf(card.suit);  

    if (card.number == 14) {
        column = 0
    } else {
        column = card.number - 1;   
    }

    pixelsLeft = card_width * column;
    pixelsTop = card_height * row;

    
    context.drawImage(card_img, pixelsLeft, pixelsTop, card_width, card_height, x, y, card_width, card_height);
}

function renderSmallerCard(card, x, y) {

    suits = ["D", "H", "C", "S"];

    row = suits.indexOf(card.suit);  

    if (card.number == 14) {
        column = 0
    } else {
        column = card.number - 1;   
    }

    pixelsLeft = card_width * column;
    pixelsTop = card_height * row;

    
    context.drawImage(card_img, pixelsLeft, pixelsTop, card_width, card_height, x, y, card_width/1.4, card_height/1.4);  
}

function clearFloor() {
    context.clearRect(0, 0, window.innerWidth, window.innerHeight);
}


            </script>

        </body>
    </html>
